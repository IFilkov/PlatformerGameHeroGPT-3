<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Platformer Game</title>
<style>
    body {
        margin: 0;
        padding: 0;
        display: flex;
        justify-content: center;
        align-items: center;
        height: 100vh;
        background-color: #f0f0f0;
    }
    canvas {
        border: 2px solid #000;
        background-color: lightblue;
    }
</style>
</head>
<body>
<canvas id="gameCanvas" width="800" height="600"></canvas>
<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    const platformWidth = 100;
    const platformHeight = 20;
    const ladderWidth = 10;
    const ladderHeight = 50;
    const platformCount = 10;
    const coinSize = 10;
    const bonusSize = 15;
    const heroWidth = 20;
    const heroHeight = 20;
    const heroJumpHeight = 100;
    const jumpHeight = 4 * heroHeight; // Высота прыжка - 6 квадратов
    const jumpSpeed = 8; // Скорость прыжка
    const gravity = 0.2;
    const maxLife = 3;

    let platforms = [];
    let ladders = [];
    let coins = [];
    let bonuses = [];
    let hero = { x: 0, y: 0, dx: 0, dy: 0, onPlatform: false, onLadder: false, jumping: false, life: maxLife, score: 0 };
    let enemies = [];

    function init() {
        generatePlatforms();
        generateLadders();
        generateCoins();
        placeHero();
        draw();
        document.addEventListener('keydown', handleKeyDown);
        document.addEventListener('keyup', handleKeyUp);
        requestAnimationFrame(update);
    }

    // function generatePlatforms() {
    //     for (let i = 0; i < platformCount; i++) {
    //         let platformX, platformY;
    //         do {
    //             platformX = Math.random() * (canvas.width - platformWidth);
    //             platformY = i * (canvas.height / platformCount);
    //         } while (platforms.some(platform => Math.abs(platformX - platform.x) < platformWidth && Math.abs(platformY - platform.y) < platformHeight) ||
    //                  coins.some(coin => Math.abs(platformX - coin.x) < platformWidth && Math.abs(platformY - coin.y) < platformHeight) ||
    //                  ladders.some(ladder => Math.abs(platformX - ladder.x) < platformWidth && Math.abs(platformY - ladder.y) < platformHeight) ||
    //                  platforms.some(platform => Math.abs(platformX + platformWidth - platform.x) < platformWidth && Math.abs(platformY - platform.y) < platformHeight) ||
    //                  platforms.some(platform => Math.abs(platformY - platform.y) < platformHeight));

    //         platforms.push({ x: platformX, y: platformY });
    //     }
    // }

        function generatePlatforms() {
        for (let i = 0; i < platformCount; i++) {
            let platformX, platformY;
            do {
                platformX = Math.random() * (canvas.width - platformWidth);
                platformY = i * (canvas.height / platformCount);
            } while (platforms.some(platform => Math.abs(platformX - platform.x) < platformWidth && Math.abs(platformY - platform.y) < platformHeight) ||
                     coins.some(coin => Math.abs(platformX - coin.x) < platformWidth && Math.abs(platformY - coin.y) < platformHeight) ||
                     ladders.some(ladder => Math.abs(platformX - ladder.x) < platformWidth && Math.abs(platformY - ladder.y) < platformHeight) ||
                     platforms.some(platform => Math.abs(platformX + platformWidth - platform.x) < platformWidth && Math.abs(platformY - platform.y) < platformHeight) ||
                     platforms.some(platform => Math.abs(platformY - platform.y) < platformHeight) ||
                     enemies.some(enemy => Math.abs(platformX - enemy.x) < platformWidth && Math.abs(platformY - enemy.y) < platformHeight));

            platforms.push({ x: platformX, y: platformY });
        }
    }


    function generateLadders() {
        for (let i = 0; i < platformCount - 1; i++) {
            const platform = platforms[i];
            const ladderX = platform.x + (platformWidth - ladderWidth) / 2;
            const ladderY = platform.y - ladderHeight;
            ladders.push({ x: ladderX, y: ladderY });
        }
    }

    function generateCoins() {
        coins = []; // Очищаем массив монеток перед генерацией новых
        platforms.forEach(platform => {
            const coinX = platform.x + Math.random() * (platformWidth - 2 * coinSize) + coinSize;
            const coinY = platform.y - coinSize;
            coins.push({ x: coinX, y: coinY, collected: false });
        });
    }

    function generateBonus() {
        const x = Math.random() * (canvas.width - bonusSize);
        const y = Math.random() * (canvas.height - bonusSize);
        bonuses.push({ x, y, collected: false });
    }

    function placeHero() {
        const randomPlatform = platforms[Math.floor(Math.random() * platforms.length)];
        hero.x = randomPlatform.x + (platformWidth - heroWidth) / 2;
        hero.y = randomPlatform.y - heroHeight;
    }

    function generateEnemies() {
    // Генерируем врагов, если герой набрал 200 очков и враги еще не были сгенерированы
            if (hero.score >= 20 && enemies.length === 0) {
                for (let i = 0; i < 5; i++) { // Создаем пять врагов
                    const randomPlatform = platforms[Math.floor(Math.random() * platforms.length)]; // Случайная платформа
                    const enemyX = randomPlatform.x + (platformWidth - heroWidth) / 2; // Позиция по X
                    const enemyY = randomPlatform.y - heroHeight; // Позиция по Y (по верху платформы)
                    enemies.push({ x: enemyX, y: enemyY, dx: Math.random() > 0.5 ? -1 : 1 }); // Добавляем врага в массив
                }
            }
        }

    function drawEnemies() {
        enemies.forEach(enemy => {
            ctx.fillStyle = '#008000'; // Зеленый цвет
            ctx.fillRect(enemy.x, enemy.y, heroWidth, heroHeight); // Отрисовываем врага
        });
    }

    function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        platforms.forEach(platform => {
            ctx.fillStyle = '#0000ff';
            ctx.fillRect(platform.x, platform.y, platformWidth, platformHeight);
        });
        ladders.forEach(ladder => {
            ctx.fillStyle = '#8B4513';
            ctx.fillRect(ladder.x, ladder.y, ladderWidth, ladderHeight);
        });
        coins.forEach(coin => {
            if (!coin.collected) {
                ctx.fillStyle = '#ffff00';
                ctx.fillRect(coin.x, coin.y, coinSize, coinSize);
            }
        });
        bonuses.forEach(bonus => {
            if (!bonus.collected) {
                ctx.fillStyle = '#800080';
                ctx.fillRect(bonus.x, bonus.y, bonusSize, bonusSize);
            }
        });
        ctx.fillStyle = '#ff0000';
        ctx.fillRect(hero.x, hero.y, heroWidth, heroHeight);
        ctx.fillStyle = '#000';
        ctx.font = '20px Arial';
        ctx.textAlign = 'center';
        ctx.fillText(`Life: ${hero.life}`, canvas.width / 2, 30);
        ctx.fillText(`Score: ${hero.score}`, canvas.width / 2, 60);

        drawEnemies();// Новые изменения!
    }

    function handleKeyDown(event) {
        if (event.key === 'ArrowLeft') {
            hero.dx = -2;
        } else if (event.key === 'ArrowRight') {
            hero.dx = 2;
        } else if (event.key === 'ArrowUp') {
            if (hero.onLadder) {
                hero.dy = -2;
                hero.dx = 0; // Prevent horizontal movement on ladder
            }
        } else if (event.key === 'ArrowDown') {
            if (hero.onLadder) {
                hero.dy = 2;
                hero.dx = 0; // Prevent horizontal movement on ladder
            }
        } else if (event.key === ' ') { // Обработка клавиши "пробел"
            if (!hero.jumping && hero.onPlatform) { // Прыгаем только если не в состоянии прыжка и на платформе
                hero.dy = -jumpSpeed; // Устанавливаем скорость прыжка вверх
                hero.jumping = true; // Устанавливаем флаг состояния прыжка
            }
        }
    }

    function handleKeyUp(event) {
        if (event.key === 'ArrowLeft' || event.key === 'ArrowRight') {
            hero.dx = 0;
        } else if (event.key === 'ArrowUp' || event.key === 'ArrowDown') {
            hero.dy = 0;
        } else if (event.key === ' ') { // Обработка клавиши "пробел"
            if (hero.jumping) { // Если был в состоянии прыжка
                hero.dy = gravity; // Возвращаем гравитацию
            }
        }
    }

    // Функция для обновления позиций врагов
function updateEnemies() {
    enemies.forEach(enemy => {
        let onPlatform = false; // Флаг, указывающий, что враг находится на платформе

        // Проверяем столкновение врага с платформами
        platforms.forEach(platform => {
            if (enemy.x + heroWidth >= platform.x && enemy.x <= platform.x + platformWidth) {
                if (enemy.y + heroHeight === platform.y) { // Враг на платформе
                    onPlatform = true; // Устанавливаем флаг, что враг на платформе
                    // Проверяем, не достиг ли враг края платформы
                    if (enemy.x <= platform.x || enemy.x + heroWidth >= platform.x + platformWidth) {
                        enemy.dx *= -1; // Обратное направление движения
                    }
                }
            }
        });

        // Если враг на платформе, его направление движения не меняется при столкновении с лестницами
        if (!onPlatform) {
            // Проверяем столкновение врага с лестницами
            ladders.forEach(ladder => {
                if (enemy.x + heroWidth >= ladder.x && enemy.x <= ladder.x + ladderWidth) {
                    if (enemy.y + heroHeight >= ladder.y && enemy.y <= ladder.y + ladderHeight) { // Враг на лестнице
                        // Проверяем, не достиг ли враг края лестницы
                        if (enemy.x <= ladder.x || enemy.x + heroWidth >= ladder.x + ladderWidth) {
                            enemy.dx *= -1; // Обратное направление движения
                        }
                    }
                }
            });
        }

        // Обновляем позицию врага
        enemy.x += enemy.dx;
    });
}



function update() {
    if (!hero.onLadder) { // Apply gravity only if not on ladder
        hero.dy += gravity;
    }

    // Move enemies
    enemies.forEach(enemy => {
        if (!enemy.onLadder) { // Move horizontally if not on ladder
            enemy.dx = Math.random() * 2 - 1; // Random horizontal movement
            enemy.x += enemy.dx;
        } else { // Move vertically if on ladder
            enemy.dy = Math.random() * 2 - 1; // Random vertical movement
            enemy.y += enemy.dy;
        }
    });

    // Horizontal movement
    hero.x += hero.dx;
    if (hero.x < 0) {
        hero.x = 0;
    } else if (hero.x + heroWidth > canvas.width) {
        hero.x = canvas.width - heroWidth;
    }

    // Vertical movement
    hero.y += hero.dy;

    // Check collision with platforms
    hero.onPlatform = false;
    platforms.forEach(platform => {
        if (hero.x < platform.x + platformWidth &&
            hero.x + heroWidth > platform.x &&
            hero.y + heroHeight > platform.y &&
            hero.y < platform.y + platformHeight) {
            hero.dy = 0;
            hero.jumping = false;
            hero.onPlatform = true;
            hero.y = platform.y - heroHeight;
        }
    });

    // Check collision with ladders
    hero.onLadder = false;
    ladders.forEach(ladder => {
        if (hero.x < ladder.x + ladderWidth &&
            hero.x + heroWidth > ladder.x &&
            hero.y + heroHeight > ladder.y &&
            hero.y < ladder.y + ladderHeight) {
            hero.onLadder = true;
            if (hero.dy > 0) { // Moving downwards on ladder
                const nextPlatformIndex = platforms.findIndex(platform => platform.y > ladder.y && platform.x === ladder.x);
                if (nextPlatformIndex !== -1) {
                    const nextPlatform = platforms[nextPlatformIndex];
                    if (hero.y + heroHeight + hero.dy > nextPlatform.y) { // Reached next platform, stop descending
                        hero.dy = 0;
                        hero.y = nextPlatform.y - heroHeight;
                    }
                }
            }
        }
    });

    // Check collision with coins
    coins.forEach(coin => {
        if (!coin.collected &&
            hero.x < coin.x + coinSize &&
            hero.x + heroWidth > coin.x &&
            hero.y < coin.y + coinSize &&
            hero.y + heroHeight > coin.y) {
            coin.collected = true;
            hero.score += 10;

            // Check if the hero collected 10 coins
            // Check if the hero collected 10 coins
        if (hero.score % 100 === 0) {
            platforms = [];
            ladders = [];
            coins = [];
            enemies = []; // Disable enemies when score reaches 200
            generatePlatforms();
            generateLadders();
            generateCoins();
            generateEnemies();
        } else if (hero.score === 0) {
            enemies = []; // Disable enemies when score resets to 0
        }

        }
    });

    // Check collision with bonuses
    bonuses.forEach(bonus => {
        if (!bonus.collected &&
            hero.x < bonus.x + bonusSize &&
            hero.x + heroWidth > bonus.x &&
            hero.y < bonus.y + bonusSize &&
            hero.y + heroHeight > bonus.y) {
            bonus.collected = true;
            const extraLife = Math.floor(Math.random() * 3) + 1;
            hero.life += extraLife;
        }
    });

    // Check if the hero falls off the canvas
    if (!hero.onLadder && hero.y > canvas.height) {
        hero.life--;
        if (hero.life === 0) {
            // Game over logic
            gameOver();
            return;
        }
        placeHero();
    }

    


        draw();
        generateEnemies(); // Генерация врагов
        updateEnemies(); // Обновление позиций врагов
        requestAnimationFrame(update);
    }

    setInterval(() => {
        if (hero.life < maxLife) {
            generateBonus();
        }
    }, 5000); // Generate bonus every 5 seconds when life < maxLife

    function gameOver() {
        // Останавливаем игру
        cancelAnimationFrame(animationFrame);

        // Отображаем сообщение "Game Over" и количество набранных очков
        const score = hero.score;
        const gameOverText = `Game Over. Score: ${score}`;
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = 'black';
        ctx.font = '30px Arial';
        ctx.textAlign = 'center';
        ctx.fillText(gameOverText, canvas.width / 2, canvas.height / 2);

        // Добавляем кнопку Restart
        // const restartButton = document.createElement('button');
        // restartButton.textContent = 'Restart';
        // restartButton.style.position = 'absolute';
        // restartButton.style.top = `${canvas.height / 2 + 50}px`;
        // restartButton.style.left = `${canvas.width / 2 - 50}px`;
        // restartButton.addEventListener('click', restartGame);
        // canvas.parentNode.appendChild(restartButton);

        // Добавляем кнопку Restart
        const restartButton = document.createElement('button');
        restartButton.textContent = 'Restart';
        restartButton.style.position = 'absolute';
        restartButton.style.top = `${(canvas.height - 80) / 1}px`;
        // restartButton.style.left = `${(canvas.width - 50) / 2}px`;
        restartButton.addEventListener('click', restartGame);
        canvas.parentNode.appendChild(restartButton);


    }

    function restartGame() {
        // Удаляем кнопку Restart
        const restartButton = document.querySelector('button');
        restartButton.parentNode.removeChild(restartButton);

        // Сбрасываем параметры и перезапускаем игру
        platforms = [];
        ladders = [];
        coins = [];
        bonuses = [];
        enemies = []; // Disable enemies when score resets to 0
        hero = { x: 0, y: 0, dx: 0, dy: 0, onPlatform: false, onLadder: false, jumping: false, life: maxLife, score: 0 };

        init();
    }

    let animationFrame = null; // Ссылка на текущий кадр анимации
    init();
</script>
</body>
</html>
